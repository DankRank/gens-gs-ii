Zipped Original Memory from Genesis
Version 0.1, Draft Revision 0
Copyright (c) 2008-2015 by David Korth.

================================================================

Permission is granted to copy, distribute and/or modify this
document under the terms of the GNU Free Documentation License,
Version 1.3 or any later version published by the Free Software
Foundation; with no Invariant Sections, no Front-Cover Texts and
no Back-Cover Texts.  A copy of the license is included in the
section entitled "GNU Free Documentation License".

================================================================

0. Draft Document Notice

WARNING: This document is a draft version of an upcoming file format.
Please do not write an implementation of the file format using this
document, as the file format may change during the draft process, which
may break compatibility with the version described in this document.

Upcoming release versions:

- 0.8: Full Genesis/Mega Drive support.

- 0.9: Support for either Sega CD or 32X, depending on which is
       implemented first in Gens/GS II.

- 1.0: Support for the other component not implemented in 0.9.

================================================================

1. What is Zipped Original Memory from Genesis?

Zipped Original Memory from Genesis, or ZOMG, is a new savestate format
for emulators for Sega consoles, including the Sega Master System and
the Sega Genesis / Mega Drive. Whereas most savestate formats have hardcoded
offsets for segments, ZOMG uses a Zip file that contains each segment as
a separate file.

The pathname convention used in this document is Unix-style; however,
Windows-style pathnames can be used for emulators running on Windows.

Due to the similarities between most of the Sega 8-bit and 16-bit systems,
common components shared between the systems will be stored in a /common
subdirectory. System-specific data will be stored in a system-specific
subdirectory, e.g. /SMS for Sega Master System or /MD for Sega Mega Drive.

Save files may have a specified endianness. They are "BE" for Big Endian
(Motorola format) and "LE" for Little Endian (Intel format), along with
an optional word-size specifier, e.g. 16BE or 32LE.

All structs are packed; that is, they do not have any padding that would
usually be added by a compiler. On gcc, this is achieved by using
__attribute__ ((packed)). On MSVC and other compilers, this may be
done by using #pragma pack(1), followed by #pragma pack() after the
struct definition.

================================================================

2. ZOMG.ini

Every ZOMG archive contains at least one file: /ZOMG.ini
This file is a text file in INI format, encoded using UTF-8.
Line endings may be either Unix-style ("\n") or Windows-style
("\r\n"). Linebreaks may be embedded within values by using the
"\n" escape sequence.

Here is an example ZOMG.ini file:

[ZOMG]
FileType=Zipped Original Memory from Genesis
Version=0.1
System=MD
Creator=Genesis Emulator
CreatorVersion=2.12.194
CreatorVcsVersion=git: master/12345678
Author=Mario Mario
ROM=Sonic the Hedgehog (W) (REV01) [!].gen
ROM CRC32=0xAFE05EEE
Region=U
Description=Sample savestate from Sonic 1.
Extensions=

Fields: ('*' indicates required; '-' indicates optional.)

* FileType: Contains the filetype. Must be "Zipped Original Memory from Genesis".
* Version: ZOMG specification version number.
* System: Systems used for the savestate, comma-separated.
- Creator: Program that created the savestate.
- CreatorVersion: Version of Creator.
- CreatorVcsVersion: Version control identifier of Creator.
- Author: Person who created the savestate.
- ROM: Filename of the ROM file used to create the savestate.
- ROM CRC32: CRC32 checksum of the ROM file used to create the savestate.
- Region: Region code of the system used to create the savestate.
- Description: A short description of the savestate.
- Extensions: Any extensions to the base format, comma-separated.

For the System value, System may be a combination of more than one system.
Each system is comma-separated and case-insensitive.

Acceptable values for Version 0.8:
- MD: Mega Drive / Genesis.

Planned values for Version 0.9/1.0:
- MCD: Mega CD / Sega CD. (implies MD)
- 32X: Sega 32X. (implies MD)

Planned values for Version 1.1/1.2:
- SMS: Sega Master System.
- GG: Game Gear. (implies SMS)

For Sega CD games, the System value would contain either "MCD" or "MD,MCD".
Sega CD 32X games would have a System value of either "MCD,32X" or "MD,MCD,32X".

The ROM field is for user reference only. It should not be used by an emulator
to determine which ROM to load, or if a savestate is valid for a given ROM.

The ROM_CRC32 field is also for user reference, but it can be used by an
emulator to verify if the savestate is compatible with the loaded ROM.
This field should be interpreted as hexadecimal if it starts with 0x;
otherwise, it should be interpreted as decimal.

The Region field indicates what region the emulator was set to when the
savestate was created. It may have one of four values:
- U: North America, NTSC.
- E: Europe, PAL.
- J: Japan, NTSC.
- A: Southeast Asia, PAL.

The Extensions field is usually blank for ZOMG files conforming to the
ZOMG version listed in the Version field. It is included to allow for
custom extensions to the format.

Note: For improved usability, the emulator may also store some of the fields
in the Zip Comments section. The Zip Comments section is only to be used as
a descriptive item and should not be interpreted as format information.

================================================================

3. Optional files in the root directory

The following files are optional, but highly recommended:

/preview.png: A preview screenshot of the savestate.

================================================================

4. Common components

The following files are contained in the /common directory. These refer to
components that are common throughout the Sega 8-bit and 16-bit hardware line.

+----------------+----------------+------------+
| Filename       |  Size (bytes)  | Endianness |
+----------------+----------------+------------+
| vdp_reg.bin    |      8; 11; 24 |    8-bit   |
| vdp_ctrl.bin   |            TBD |     TBD    |
| VRam.bin       | 16,384; 65,536 |   Varies   |
| CRam.bin       |    32; 64; 128 |   Varies   |
| psg.bin        |             23 |    8-bit   |
| Z80_mem.bin    |    1, 2, 8 KiB |    8-bit   |
| Z80_reg.bin    |             28 |     LE     |
| SRAM.bin       |   up to 65,536 |    8-bit   |
+----------------+----------------+------------+

----------------------------------------------------------------

4.1. vdp_reg.bin: Sega VDP registers (TMS9918A-like)

This file contains the user-accessible registers found in the VDP used
on Sega's 8-bit and 16-bit consoles. The SG-1000 and SG-1000 Mark II
both used a TMS9918A, while the Sega Mark III and later used custom VDPs.
Each register is 8 bits wide.

Depending on the system being emulated, the number of VDP registers
may vary:

- SG-1000 (TMS9918A):   8 registers
- Sega Mark III (SMS): 11 registers
- Sega Mega Drive:     24 registers

vdp_reg.bin contains only the VDP registers, so the C equivalent may
look like this:

uint8_t vdp_reg_tms9918a[8];	// TMS9918A-based systems. (SG-1000, ColecoVision)
uint8_t vdp_reg_mk3[11];	// Sega Mark III / Sega Master System.
uint8_t vdp_reg_md[24];		// Sega Mega Drive.

----------------------------------------------------------------

4.2. vdp_ctrl.bin: Sega VDP control registers

The VDP control registers are internal counters that maintain the VDP's
state. The control registers have different formats depending on whether
the system is in 8-bit mode (SMS/GG) or 16-bit mode (MD). The structure
has a header indicating whether it's 16-bit or 8-bit; if the header doesn't
match the expected value, the program should cancel loading the savestate.

TODO: Some emulators do not support the FIFO. Figure out how to implement
the FIFO in these emulators.

TODO: Internal DMA registers: DMA destination, etc.

C equivalent for vdp_ctrl.bin:

// 8-bit VDP (Master System)
typedef struct _ZOMG_VDP_ctrl_8_t {
	uint32_t header;		// 32BE: Should be 'SMS ' (0x534D5320)
	uint8_t reserved1[4];		// Reserved.

	uint8_t ctrl_latch;		// 8-bit: Control latch. 0 == first word; 1 == second.
	uint8_t code;			// 8-bit: VDP access code. (CD1-CD0)

	uint16_t address;		// 16BE: VDP address counter.
	uint8_t status;			// 8-bit: VDP status register.
	uint8_t reserved2;

	uint8_t data_read_buffer;	// 8-bit: Data read buffer.
} ZOMG_VDP_ctrl_8_t;

TODO: Definitions of "access" for Sega 8-bit. It'll probably be the same
as the low byte of "access" for Sega Mega Drive.

// 16-bit VDP (Mega Drive)
typedef struct _ZOMG_VDP_ctrl_16_t {
	uint32_t header;		// 32BE: Should be 'MD  ' (0x4D442020)
	uint8_t reserved1[4];		// Reserved.

	uint8_t ctrl_latch;		// 8-bit: Control latch. 0 == first word; 1 == second.
	uint8_t code;			// 8-bit: VDP access code. (CD5-CD0)

	uint16_t address;		// 16BE: VDP address counter.
	uint16_t status;		// 16BE: VDP status register.

	uint16_t data_fifo[4];		// 16BE: Data FIFO. (4 words)
	uint8_t data_fifo_count;	// 8-bit: Number of words currently in the FIFO.
	uint8_t reserved2;
} ZOMG_VDP_ctrl_16_t;

NOTE: reserved1[4] was previously "ctrl_byte" (SMS) and "ctrl_word" (MD), which
contained the two control bytes or words that were written to the VDP. These
are not actually stored in the VDP, so they're no longer stored in the save file;
however, for compatibility, the space is now reserved.

NOTE: The internal data buffer *does* exist on MD, though it has less of an
effect due to misuse than the SMS version. reserved1[] may be repurposed
for the internal data buffer at a later point.

The "code" field contains the CD5-CD0 bits (CD1-CD0 for Sega 8-bit) from
the last pair of control words. This indicates the destination for the
next read or write operation, as well as the read/write mode and (on MD)
DMA access mode.

Note that on MD, this field should never be equal to 0x02 (register write),
since both the code and address registers are cleared after a register
write command is executed.

----------------------------------------------------------------

4.3. VRam.bin: Video RAM

Video RAM is directly connected to the Video Display Processor on
the Sega 8-bit and 16-bit machines. Depending on the system, it may
have a different size and format:

- All Sega 8-bit systems: 16,384 bytes; 8-bit
- Sega Mega Drive:        32,768 words; 16-bit BE

C equivalents for VRam.bin:
uint8_t vram_8bit[16384];	// Sega 8-bit systems.
uint16_t vram_md[32768];	// Sega Mega Drive. (16BE)

----------------------------------------------------------------

4.4. CRam.bin: Color RAM

Starting with the Sega Mark III, Sega's 8-bit and 16-bit VDPs
have included Color RAM, which allows the onscreen palette to
be remapped. There are three different Color RAM formats.

- Sega Mark III (SMS):  32 bytes; 8-bit (6 bits per color usable)
- Sega Mega Drive:     128 bytes; 16-bit BE (9 bits per color usable)
- Sega Game Gear:       64 bytes; 16-bit LE (12 bits per color usable)

C equivalents for CRam.bin:
uint8_t cram_mk3[32];		// Sega Mark III / Sega Master System.
uint16_t cram_md[64];		// Sega Mega Drive. (16BE)
uint16_t cram_gg[32];		// Sega Game Gear. (16LE)

----------------------------------------------------------------

4.5. psg.bin: TI SN76489(A) Programmable Sound Generator

This file contains the register values from the TI SN76489(A) Programmable
Sound Generator. This chip is used for generating square waves and noise.

Note that the SG-1000 and SG-1000 Mark II systems used an SN76489, while
the Sega Mark III and later used an SN76489A integrated in the VDP. The
primary difference is the linear feedback shift register length. In the
SN76489, the register is 15 stages, while in the SN76489, the register is
16 stages. (This is hardware-dependent, and is not stored in psg.bin.)

Additionally, the Game Gear variant of the PSG supports stereo sound.
The stereo field in the psg.bin file is used for this purpose, and should
be ignored for all other systems.

Layout of the stereo byte: (active high)
+-----+---------+-------+
| Bit | Channel | Side  |
+-----+---------+-------+
|  0  |    0    | Right |
|  1  |    1    | Right |
|  2  |    2    | Right |
|  3  |    3    | Right |
|  4  |    0    | Left  |
|  5  |    1    | Left  |
|  6  |    2    | Left  |
|  7  |    3    | Left  |
+-----+---------+-------+

For the tone_reg[] field, the Tone channels (0-2) have 10 significant bits,
while the Noise channel (3) has 3 significant bits.

For the vol_reg[] field, each channel has 4 significant bits.

For the tone_ctr[] field, if an emulator does not support saving the
internal counters, it should write 0xFFFF to indicate this.

For the gg_stereo field, if an emulator does not support Game Gear stereo,
set the field to 0xFF.

C equivalent for psg.bin:

typedef struct _ZOMG_psg_t {
	uint16_t tone_reg[4];	// 16LE: Tone values for each channel.
	uint8_t vol_reg[4];	// 8-bit: Volume values for each channel.

	uint16_t tone_ctr[4];	// 16LE: Internal counter values for each channel.
	uint16_t lfsr_state;	// 16LE: Linear Feedback Shift Register state.

	uint8_t gg_stereo;	// 8-bit: Stereo register. (Game Gear only.)
} ZOMG_psg_t;

----------------------------------------------------------------

4.6. Z80_mem.bin: Zilog Z80 memory.

This file contains the system memory that is directly accessible by the
Z80 CPU. The Z80 memory size depends on the console. Z80 memory is 8-bit,
since the Z80 CPU is an 8-bit processor.

Memory sizes:
- Sega SG-1000:        2,048 bytes
- ColecoVision:        1,024 bytes
- Sega Mark III (SMS): 8,192 bytes
- Sega Mega Drive:     8,192 bytes

C equivalents for Z80_mem.bin:

uint8_t Z80_mem_sg1000[2048];	// Sega SG-1000.
uint8_t Z80_mem_cv[1024];	// ColecoVision.
uint8_t Z80_mem_mk3[8192];	// Sega Mark III (SMS), Sega Mega Drive

----------------------------------------------------------------

4.7. Z80_reg.bin: Zilog Z80 registers.

This file contains the registers found in the Z80 CPU.

C equivalent for Z80_reg.bin:

typedef struct _ZOMG_Z80_reg_t {
	// Main register set.
	uint16_t AF;	// 16LE: AF register.
	uint16_t BC;	// 16LE: BC register.
	uint16_t DE;	// 16LE: DE register.
	uint16_t HL;	// 16LE: HL register.
	uint16_t IX;	// 16LE: IX register.
	uint16_t IY;	// 16LE: IY register.
	uint16_t PC;	// 16LE: PC register.
	uint16_t SP;	// 16LE: SP register.

	// Shadow register set.
	uint16_t AF2;	// 16LE: AF' register.
	uint16_t BC2;	// 16LE: BC' register.
	uint16_t DE2;	// 16LE: DE' register.
	uint16_t HL2;	// 16LE: HL' register.

	// Other registers.
	uint8_t IFF;	// 8-bit: IFF flipflops. [0 0 0 0 0 0 IFF2 IFF1]
	uint8_t R;	// 8-bit: R register.
	uint8_t I;	// 8-bit: I register.
	uint8_t IM;	// 8-bit: IM register. (0, 1, 2)
} ZOMG_Z80_reg_t;

----------------------------------------------------------------

4.8. SRAM.bin: Save RAM. [OPTIONAL]

This file contains the contents of Save RAM, which is present
in some cartridges.

On Sega 8-bit systems, the Save RAM contents is stored as 8-bit data.

On the Sega Mega Drive, the Save RAM is technically 16-bit, since the system
bus is 16-bit, but only 8-bit SRAM chips are used. Some games put the SRAM
chip on odd bytes, and others use even bytes. In order to accomodate both
types, the full 16-bit data is saved in its native format, which is considered
"big-endian" by the CPU, but we're treating it as 8-bit.

Save RAM should be initialized with 0xFF.

Save RAM can be up to 65,536 bytes in the ZOMG format, and file sizes should
be powers of 2. If the Save RAM file in a savestate is smaller than the total
Save RAM area in the emulator, the remainder should be filled with 0xFF.

Note that saving SRAM in a savestate is optional. For emulators that support
it, there should be a user-configurable option to enable or disable saving
SRAM in savestates.

C equivalent for SRAM.bin:
uint8_t sram[65536];	// Up to 65,536 bytes.

================================================================

5. Mega Drive-specific components

The following files are contained in the /MD directory. These refer to
components that are specific to the Sega Mega Drive hardware.

+----------------+----------------+------------+
| Filename       |  Size (bytes)  | Endianness |
+----------------+----------------+------------+
| VSRam.bin      |             80 |  16-bit BE |
| YM2612_reg.bin |            512 |    8-bit   |
| M68K_mem.bin   |         65,536 |  16-bit BE |
| M68K_reg.bin   |             80 |     BE     |
| IO.bin         |             16 |    8-bit   |
| Z80_ctrl.bin   |              4 |   Varies   |
| TIME_reg.bin   |            256 |    8-bit   |
| TMSS_reg.bin   |              9 |   Varies   |
| vdp_sat.bin    |            320 |  16-bit BE |
+----------------+----------------+------------+

----------------------------------------------------------------

5.1. VSRam.bin: Vertical Scroll RAM

This file contains the Vertical Scroll RAM found in the Mega Drive VDP.
This memory controls the vertical scrolling attributes.

40 words are available in VSRam. Depending on the scrolling mode, even words
control 2-cell columns in plane A and odd words control 2-cell columns in
plane B, or the first two words control the entirety of plane A and plane B,
respectively.

Note: In most cases, only the lower 10 bits of each VSRam word are used.
In interlaced mode, 11 bits are used.

C equivalents for VSRam.bin:
uint16_t md_vsram[40];		// 16BE: Vertical Scroll RAM.
uint16_t md_vsram[20][2];	// Alternate version with simplied A/B access.

----------------------------------------------------------------

5.2. YM2612_reg.bin: Yamaha YM2612 registers

This file contains the user-accessible registers found in the Yamaha YM2612
FM synthesis chip used on the Sega Mega Drive. Each register is 8 bits wide,
and the registers are split into two 256-register banks.

Note: The internal YM timer counters are not stored in this file.
They may be added to another file later on.

C equivalent for YM2612_reg.bin:

uint8_t ym2612_reg[2][512];	// 8-bit: Yamaha YM2612 registers.

----------------------------------------------------------------

5.3. M68K_mem.bin: Main MC68000 memory.

This file contains the 64 KiB main memory connected to the MC68000.
Main memory is accessed in 16-bit words in big-endian notation.

C equivalent for M68K_mem.bin:

uint16_t m68k_mem[32768];	// 16BE: M68K memory.

----------------------------------------------------------------

5.4. M68K_reg.bin: Main MC68000 registers.

This file contains the registers found in the MC68000 CPU.

Note: The reserved values may be used in the future, so they should
be set to 0 for now.

C equivalent for M68K_reg.bin:

typedef struct _ZOMG_M68K_reg_t {
	uint32_t dreg[8];	// 32BE: Data registers.
	uint32_t areg[7];	// 32BE: Address registers. (a0-a6)
	uint32_t ssp;		// 32BE: Supervisor stack pointer. (a7/super)
	uint32_t usp;		// 32BE: User stack pointer. (a7/user)
	uint32_t pc;		// 32BE: Program counter.
	uint16_t sr;		// 16BE: Status register.
	uint16_t reserved1;	// 16BE: Reserved.
	uint32_t reserved2;	// 32BE: Reserved.
} ZOMG_M68K_reg_t;

***WARNING***: The layout of ZOMG_M68K_reg_t has changed:

- dreg/areg order now matches the MC68000 CPU.

- ssp and usp are strictly defined instead of being stored as
  areg[7] and alternate stack pointer.

Previous revisions of the ZOMG specification used the following
layout for M68K_reg.bin:

typedef struct _ZOMG_M68K_reg_OLD_t {
	uint32_t areg[8];	// 32BE: Address registers.
	uint32_t dreg[8];	// 32BE: Data registers.
	uint32_t pc;		// 32BE: Program counter.
	uint32_t asp;		// 32BE: Alternate stack pointer.
	uint16_t sr;		// 16BE: Status register.
} ZOMG_M68K_reg_OLD_t;

asp is either User Stack Pointer if sr indicates supervisor mode,
or Supervisor Stack Pointer if sr indicates user mode.

To differentiate between old and new versions, check the size of the
data from the savestate. The new version is 80 bytes, while the old
version is 74 bytes.

----------------------------------------------------------------

5.5. IO.bin: Mega Drive I/O state.

This file contains the current state of the I/O ports in the $A10000 region.

Each I/O port has a 16-bit address; however, only the low byte is mapped to
an actual register, so only the low byte will be stored in IO.bin.

Notes:

- The version register ($A10001) only has two bits relevant for savestates:
  NTSC/PAL and East/West. These bits should be restored by changing the
  system region setting when loading the savestate, but this can be
  overridden by the user.

- For the Control Port Data registers, the saved value should be the last
  value written to the port by the M68K.

- If an emulator doesn't support a particular Control Port or specific
  functionality of a Control Port, fill in the unsupported fields using
  the following values:

  * Data: 0xFF
  * Ctrl: 0xFF
  * Serial TxData: 0xFF
  * Serial RxData: 0xFF
  * Serial Control: 0x00

C equivalent for IO.bin:

typedef struct _ZOMG_MD_IO_t {
	uint8_t version_reg;	// $A10001: Version register.
	uint8_t port1_data;	// $A10003: Control Port 1: Data.
	uint8_t port2_data;	// $A10005: Control Port 2: Data.
	uint8_t port3_data;	// $A10007: Control Port 3: Data.
	uint8_t port1_ctrl;	// $A10009: Control Port 1: Ctrl.
	uint8_t port2_ctrl;	// $A1000B: Control Port 2: Ctrl.
	uint8_t port3_ctrl;	// $A1000D: Control Port 3: Ctrl.
	uint8_t port1_ser_tx;	// $A1000F: Control Port 1: Serial TxData.
	uint8_t port1_ser_rx;	// $A10011: Control Port 1: Serial RxData.
	uint8_t port1_ser_ctrl;	// $A10013: Control Port 1: Serial Control.
	uint8_t port2_ser_tx;	// $A10015: Control Port 2: Serial TxData.
	uint8_t port2_ser_rx;	// $A10017: Control Port 2: Serial RxData.
	uint8_t port2_ser_ctrl;	// $A10019: Control Port 2: Serial Control.
	uint8_t port3_ser_tx;	// $A1001B: Control Port 3: Serial TxData.
	uint8_t port3_ser_rx;	// $A1001D: Control Port 3: Serial RxData.
	uint8_t port3_ser_ctrl;	// $A1001F: Control Port 3: Serial Control.
} ZOMG_MD_IO_t;

----------------------------------------------------------------

5.6. Z80_ctrl.bin: Z80 control logic.

The Sega Mega Drive has a Z80 as a secondary processor. In order to control
access to the Z80, the main 68000 has special control registers to control
the state of the Z80 bus as well as the memory accessible in the Z80 banking
page (0x8000-0xFFFF in Z80 space).

C equivalent for Z80_ctrl.bin:

typedef struct _ZOMG_MD_Z80_ctrl_t {
	uint8_t busreq;		// 8-bit: BUSREQ state.
				// 0 == Z80 has the bus.
				// 1 == M68K has the bus.

	uint8_t reset;		// 8-bit: RESET state.
				// 0 == Z80 is RESET.
				// 1 == Z80 is running.

	uint16_t m68k_bank;	// 16BE: M68K banking register.
				// Low 9 bits of m68k_bank indicate
				// high 9 bits of M68K address space
				// for the Z80 banking space.
} ZOMG_MD_Z80_ctrl_t;

----------------------------------------------------------------

5.7. TIME_reg.bin: /TIME registers.

These are registers accessible using the /TIME control signal on the cartridge
slot, which is mapped to $A130xx. Typically, this control signal is used for
Save RAM banking. It's also used for the Super Street Fighter II bankswitching
scheme.

The full 256 bytes are saved, since some other bankswitching schemes may use
additional portions of the /TIME area that aren't discussed here. If an
emulator does not support a certain region of the /TIME area, it should assume
that the value is 0xFF.

NOTE: The $A130Fx range consists of byte-wide registers that are accessible
using byte writes to both odd and even addresses; however, only the odd
addresses contain the actual register data.

Format for SRAM_ctrl: [X X X X X X WP MD]
X = Don't Care (preferred value is 0)
WP = Write Protect: 0 = SRAM is writable; 1 == SRAM is not writable.
MD = Mode: 0 == ROM is accessible; 1 == SRAM is accessible.

NOTE: SRAM_ctrl is *not* used if the ROM in question uses EEPROM
instead of SRAM for saving. In this case, SRAM_ctrl should be 0.

C equivalent for TIME_reg.bin:

typedef struct _ZOMG_MD_TIME_reg_t {
	union {
		uint8_t reg[256];			// All registers.
		struct {
			uint8_t reserved_00_EF[240];	// $A13000 - $A130EF: Reserved.
			uint8_t reserved_F0;		// $A130F0: Reserved.
			uint8_t SRAM_ctrl;		// $A130F1: SRAM control.
			uint8_t reserved_F2;		// $A130F2: Reserved.
			uint8_t SSF2_bank1;		// $A130F3: SSF2 Bank 1. ($080000 - $0FFFFF)
			uint8_t reserved_F4;		// $A130F4: Reserved.
			uint8_t SSF2_bank2;		// $A130F5: SSF2 Bank 2. ($100000 - $17FFFF)
			uint8_t reserved_F6;		// $A130F6: Reserved.
			uint8_t SSF2_bank3;		// $A130F7: SSF2 Bank 3. ($180000 - $1FFFFF)
			uint8_t reserved_F8;		// $A130F8: Reserved.
			uint8_t SSF2_bank4;		// $A130F9: SSF2 Bank 4. ($200000 - $27FFFF)
			uint8_t reserved_FA;		// $A130FA: Reserved.
			uint8_t SSF2_bank5;		// $A130FB: SSF2 Bank 5. ($280000 - $2FFFFF)
			uint8_t reserved_FC;		// $A130FC: Reserved.
			uint8_t SSF2_bank6;		// $A130FD: SSF2 Bank 6. ($300000 - $37FFFF)
			uint8_t reserved_FE;		// $A130FE: Reserved.
			uint8_t SSF2_bank7;		// $A130FF: SSF2 Bank 7. ($380000 - $3FFFFF)
		};
	};
} ZOMG_MD_TIME_reg_t;

----------------------------------------------------------------

5.8. TMSS_reg.bin: TMSS registers.

Introduced on the VA6 revision of the original Mega Drive, TMSS was an
attempt to restrict unlicensed developers from releasing titles for the
system. The theory was that since it required the game cartridge to
contain the word "SEGA", which was trademarked, Sega could use trademark
law to sue unlicensed developers for trademark infringement. However, in
the case of Sega Enterprises Ltd. v. Accolade, Inc., the court ruled that
the use of the SEGA trademark in order to get past TMSS did not count as
infringement because Sega was attempting to use its trademark as a way to
limit competition for software on their console.

For more information on the history of TMSS, check out:
- http://segaretro.org/TradeMark_Security_System
- http://segaretro.org/Sega_v._Accolade
- http://en.wikipedia.org/wiki/Sega_Enterprises_Ltd._v._Accolade,_Inc.

Systems with TMSS are easily identified by this message appearing on
startup if a game cartridge is inserted:

                       PRODUCED BY OR
                     UNDER LICENSE FROM
                    SEGA ENTERPRISES LTD.

This is implemented using a tiny boot ROM (2 KB, though 4 KB is reserved
on the bus) and a couple of registers:

- $A14000: "SEGA" - 32BE value needed to initialize TMSS.
- $A14101: ROM mapping register; 0=TMSS, 1=cartridge
- $A10001: Version register - low 4 bits are 0001.

On systems without TMSS, the low 4 bits of the version register are
always 0000; with TMSS, the low 4 bits are always 0001.

On startup, the $A14101 register is set to 0, which enables the internal
TMSS ROM. This ROM checks for the presence of the strings "SEGA" or " SEGA"
at cartridge ROM address $100. If the string is not found, it halts all
activity immediately; otherwise, it shows the above startup message, waits
a few seconds, then enables the cartridge and resets the CPU.

--------

If the emulator does not support TMSS, or if the user has disabled TMSS,
this file should *not* be saved to the savestate at all. It also should
not load the TMSS registers on load.

If the emulator does support TMSS and the user has enabled it:
- The TMSS registers should be saved.
- If the TMSS registers are present in the savestate, they should be loaded.
- If the TMSS registers are not present in the savestate, they should be
  set to $A14000='SEGA' and $A14101=1.

C equivalent for TMSS_reg.bin:

typedef struct _Zomg_MD_TMSS_reg_t {
	uint32_t header;	// 32BE:  Should be 'TMSS' (0x544D5353)
	uint32_t a14000;	// 32BE:  $A14000 - 'SEGA' register
	uint8_t n_cart_ce;	// 8-bit: $A14101 - ROM mapping
} Zomg_MD_TMSS_reg_t;

----------------------------------------------------------------

5.9. vdp_sat.bin: VDP Sprite Attribute Table cache.

The Mega Drive VDP has an internal cache for the Spirte Attribute Table.
This cache can hold up to 80 sprite entries (640 bytes), and is updated
whenever a VRAM write occurs in the Sprite Attribute Table area.

NOTE: Changing the Sprite Attribute Table base address will result in
the cache getting desynchronized with the contents of VRAM, which can
cause unusual effects onscreen due to the Y, size, and link fields
being read from the cache, while the attribute and X fields are read
from VRAM.

NOTE 2: The SAT cache in ZOMG is only 320 bytes. Only the first three
fields (Y position, size, and link) are stored in the cache.

NOTE 3: If this file is missing, the cache can be created by copying
the Sprite Attribute Table from VRAM. This may not be as accurate, but
it's "good enough" in most cases.

C equivalent for vdp_sat.bin:

uint16_t vdp_sat[160];	// 16BE: VDP Sprite Attribute Table cache.
